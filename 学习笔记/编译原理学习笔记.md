---
start: 2022-09-24
tags: 学习笔记 读书笔记 计算机基础
---

# 编译原理 学习笔记

- **编译器**是将源语言编写程序等价地翻译为目标语言编写的程序的语言处理程序。如果目标程序是可执行的，那么它将被用户调用，处理输入并产生输出。**解释器**是另一种语言处理器，它直接利用用户提供的输入执行源程序中指定的操作。*也就是说，解释器仅仅执行用户输入到源语言的转换，不涉及向目标语言的翻译。*
	- Java 语言处理器结合编译和解释过程，它将源语言翻译为被称为字节码的中间语言，再对字节码解释执行。这样，通过字节码可实现机器间的迁移。
	- 编译器可能将一种高级语言翻译为另一种高级语言，这时它被称为源到源的翻译器。
	- 编译器将报告它在翻译过程中发现的源程序的错误。
- 由于源语言可能被分割为多个模块而存放于不同的文件中，因此编译前需要由**预处理器**将它们聚合在一起。预处理器还负责将那些被称为宏的缩写形式转换为源语言的语句。
	- 预处理后的源程序作为输入传入编译器后，编译器将产生一个汇编语言程序作为其输出。该汇编语言程序再由**汇编器**程序处理，并生成可重定位的机器代码。*可重定位，即机器间可迁移。*
	- 由于大型程序经常被分割为不同部分进行编译，因此汇编器处理后的机器代码须与其他机器代码以及库文件（可重定位的对象文件）连接，也就是说某一文件中的代码可能指向另一文件中的某个位置，这由**链接器**解决外部内存地址的问题。
	- 最后，**加载器**将所有可执行目标文件放到内存中执行。由此，一个语言处理系统包括：预处理器、编译器、汇编器、链接器与加载器。
- 编译器将源程序映射为语义上等价的目标程序，这一过程包括两个部分：分析和综合。**分析**部分将源程序分解为多个组成要素，使用其语法结构将这些组成要素组织为一个中间表示，它还会收集有关源程序的信息，将此信息存放为**符号表**数据结构，然后将符号表与中间表示形式一同交付综合部分。**综合**部分将根据中间表示和符号表构造用户期待的目标程序。分析部分又被称为编译器的前端，综合部分又被称为编译器的后端。
	- 编译器执行一系列步骤，包括词法分析、语法分析、语义分析、中间代码生成、代码生成，在中间代码到机器语言之间，可能经历可选的代码优化，以提高代码质量。
	- **词法分析**又称为扫描。词法分析器读取组成源程序的**字符流**，并将它们组织成为有意义的**词素**序列。对于每个词素，词法分析器将产生形式为 `<token-name, attribute-value>` 的词法单元（token）作为输出。其中，token-name 是被语法分析步骤使用的抽象符号，attribute-value 指向符号表中关于这个词法单元的条目。符号表条目的信息将被语义分析和代码生成步骤使用。词法分析器将忽视分隔词素的空格。
	- *姑且认为，符号表由一系列条目组成，其中每一条目对应一个词素，存放与之相关的信息，即属性值，包括该词素的名字和类型等。*
	- **语法分析**又称为解析。语法分析器用词法单元的 token-name 分量建立树形结构的中间表示，该树形结构表明词法单元的语法结构。该中间表示通常为**语法树**，树的每个节点表示运算，子节点表示该运算的分量。
	- **语义分析**器使用语法树和符号表中的信息检查源程序是否和语言定义的语义一致。它也收集类型信息，将其存放在语法树或符号表中，以便生成中间代码时使用。语义分析器将进行**类型检查**，即检查每个运算符是否具有匹配的运算分量。程序设计语言可能允许某些类型转换，这被称为**自动类型转换**。为了实现类型转换，语义分析器将在语法树中生成额外的用于类型转换的节点。
	- **中间代码生成**器将根据语法树和符号表生成低级的或类机器语言的中间表示（即中间代码）。该中间表示应当易于生成，且易被翻译为机器语言。如三地址代码，该中间表示由一组类似于汇编语言的指令组成，每一指令有三个运算分量。*三地址代码实际上是进行一次运算，然后将运算的结果赋值为一个新的临时变量。*
	- 机器无关的**代码优化**器将改进中间代码，以生成更好的目标代码。区分机器无关的代码优化和机器有关的代码优化。
	- **代码生成**器将中间代码映射到目标语言。如果目标语言是机器代码，那么必须为程序使用的每个变量选择寄存器（用于存储变量的值）或内存位置。中间指令将被翻译为等价的机器指令序列。
	- 上述步骤可以被组合为**趟**，每趟读取一个输入文件，并生成一个输出文件。上述自词法分析至中间代码生成往往被组合为一趟，为特定目标机生成目标代码作为独立的后端趟。
- 符号表数据结构将记录变量的名字以及该变量的各种属性相关的信息。这些属性提供存储分配、变量类型、作用域等信息，对于过程名字（*函数名*），还提供参数数量和类型、每个参数的传递方式（传值或传引用）以及返回类型等信息。*符号表数据结构根据变量的名字索引，因此变量名应当是唯一的。*
- 程序设计语言可以根据代划分，第一代语言是机器语言，第二代语言是汇编语言，第三代语言是高级程序设计语言，例如 C 、Java ，第四代语言是为特定的应用设计的语言，例如 SQL 和 Postscript（PDF），第五代语言是基于逻辑和约束的语言。
	- 指明如何完成计算任务的语言被称为强制式语言，指明要进行哪些运算的语言被称为声明式语言。所有强制式语言中都有用于表示程序状态和语句的表示方法，这些语句可以改变程序的状态。
	- 冯·诺伊曼语言是指以冯·诺伊曼计算机体系结构为计算模型的程序设计语言。
	- 面向对象语言是指支持面向对象编程的语言，面向对象编程是指用一组相互作用的对象组成程序的编程风格。
	- 脚本语言是具有高层次运算符的解释型语言，它将多个运算过程合并，这些运算过程被称为脚本。JavaScript 、PHP 、Python 是常见的脚本语言。
- *物质基础决定上层建筑，正如同人的意识被他的物质资料决定，程序也由它的硬件决定。尽管某些形式的物质基础容许其上层建筑有无限的可能性。*
- 抽象地讲，编译器的工作是抓住源程序的关键特性而用数学抽象表示，然后用数学技术将它翻译为目标程序。因此，编译器的关键问题在于**如何设计正确的数学模型**和**选择正确的算法**。最基本的数学模型是有穷状态自动机、正则表达式和上下文无关文法。树形结构也是重要的数学模型。
- 代码优化要求生成比浅显直观的代码更高效的代码，由于处理器结构体系变得复杂，尤其是多处理器并发结构，代码将有更高的优化空间以及优化要求。
- 编译器技术提高程序设计语言的[[抽象]]层次，程序员可以使用高级语言编程，而由编译器将其翻译为机器语言。抽象层次较高的语言忽视计算的细节，缩小程序员对程序的控制范围，这使得程序员可以更关注于核心问题；事实上，对于某些计算细节，程序员的人为控制甚至比起机器控制造成更大的性能损耗，例如寄存器分配和垃圾回收机制。
	- 程序设计语言抽象层次的提高也要求编译器的优化。实践中，所有程序设计语言支持由用户定义的聚合类型（如数组和结构）和高级控制流（如循环和过程调用），编译器为此实现数据流优化，分析程序的数据流并消除数据流构造中的冗余。面向对象编程将数据抽象为可继承特性的对象，将程序分解为众多对象的方法（过程），为此，编译器必须很好地跨越源程序中的过程边界进行优化。对于引入垃圾回收机制的语言，编译器需降低垃圾收集的开销。对于动态编程，编译器需要减少编译时间。
	- 计算机体系结构的发展也对编译器提出更高要求。现代计算机系统采用并行和内存层次结构。在指令层次上，多个运算可以被同时执行；在处理器层次上，同一应用的多个不同线程在不同的处理器上运行。在程序员看来，他的指令似乎是顺序执行的，编译器则需要重新安排这些指令，以使它们的并行更加有效。内存层次结构由多块具有不同速度和大小的存储器组成，离处理器越近的层速度越快但容量越小，编译器必须充分利用这些存储器。
	- 在现代计算机结构体系的开发中，编译器将影响计算机结构体系的设计，尤其是处理器的设计。
- 程序设计语言将选择编译器在何时对程序做出判定，如果该语言支持编译器静态决定某个问题，那么该语言被认为采取**静态**策略，或者说，这个问题在**编译时刻**决定；如果该语言只允许编译器在运行程序时做出决定，那么它被认为采取**动态**策略，这个问题在**运行时刻**决定。如果某一变量的作用域只需阅读源代码便可确定，那么这个语言使用的是**静态作用域**，或者说词法作用域；如果该变量在运行时动态地指向对它的几个声明中的某一个，那么这个语言使用的是**动态作用域**。*所谓决定某个问题，是决定什么问题？由书中的例子，我觉得是决定变量在内存中的位置，在静态策略中，变量在内存中的位置是唯一确定的，在动态策略中，只有运行时才能确定变调用哪个位置的变量。总之，决定作用域这个问题的策略可以分为静态和动态。* #？ 
	- 从名字到值，经过两步映射：**环境**是从变量名到内存位置（变量）的映射，**状态**是从内存位置到值的映射。环境遵循作用域规则。*如果说，内存位置与值位于内存中的不同位置，那么内存位置指向实际存储变量值的位置，因此它被称为变量。这样的话，变量名不存在于内存中，那么它可能存在于寄存器中，寄存器指向内存位置。* #？ 
	- 名字到内存位置的映射可以是静态绑定或动态绑定。内存位置到值的映射可以是静态绑定或动态绑定。一般而言，它们都是动态绑定。*在 JS 中，似乎表现为 const 声明的变量不可重新赋值。*
	> 一般而言，名字（变量名）就是变量，它们是指向内存中某特定位置的字符串（标识符）。本书要求小心地使用它们，以区分编译时刻的名字和名字在运行时刻所指的内存位置。
	> 
	> 过程、函数和方法指的是一类事物，即可被调用的子程序。函数通常返回某个类型的值，过程不返回值，面向对象编程中将与某个类绑定的过程或函数称为方法。
	- 由 `{ }` 符号标识的块是独立的作用域，其中声明的对象绑定在这一作用域中。块嵌套为块结构。
	- public 、private 、protect 这样的关键字的使用提供了对名字的显示访问控制（*对变量作用域的显式控制*），它们通过限制访问支持封装。私有（private）名字仅包含该类和「友类」相关的方法声明和定义。被保护的（protect）变量可以由子类方位。公共的（public）名字可以从类外访问。
	> 声明和定义是不同的，前者指明变量的类型，后者指明变量的值。因此，我们可以先定义变量，而后声明它们。或者，在某一文件中定义某函数，而后在其他文件中声明之。或者，在某一对象中声明某方法，然后在对象外定义之。
	- 在狭义上，动态作用域指对某一名字的调用指向的是最近被调用但还没有终止且声明了该名字的过程中的这个声明（*也就是说，某一过程声明的名字的作用域不被限制在这一过程中，而在过程后可能调用，这与静态作用域的块结构是不同的*）。静态作用域是空间作用域，动态作用域是时间作用域。
- 过程（函数）需获取参数。**实在参数**是指函数调用过程中使用的参数，**形式参数**是指在过程定义中使用的参数。两者的传递机制决定调用代码序列如何处理参数。
	- 在**值调用**中，会对实在参数求值（如果它是表达式）或拷贝（如果它是变量），这些值被放置在被调用过程中的相应形式参数的内存位置上。由此，过程中所有对参数值的改变都仅限于这个过程，而不会影响实在参数本身。但是，如果值调用中传入的是变量的指针（*引用对象*），那么，过程中对参数值的改变将改变实在参数本身。
	- 在**引用调用**中，实在参数的地址作为相应的形式参数的值被传递给被调用者（实在参数的地址被放置在相应形式参数的内存位置上）。那么，过程中对参数值的改变将影响实在参数。由于对较大的参数拷贝的代价高昂，引用调用是较好的选项。
	- 引用调用或其他方法将产生**别名**，即两个形式参数指向同一位置。编译器需要正确地理解别名，以免生成机器语言时犯错。
- *[[2022-09-24]]，晚上，四小时，至 23 页，第一章完。*

---

- 程序设计语言的语法描述该语言的程序的正确形式，该语言的语义则描述程序的含义。可以使用上下文无关法（文法，BNF）描述语言的语法，它也可以用来指导翻译的过程，因此这种面向文法的编译技术被称为语法制导翻译。
	- 文法自然地描述大多数程序设计语言构造的层次化语法结构。例如 `if (expression) statement else statement` 这样的 `if-else` 语句，它的构造规则可以表示为 `stmt → if (expr) stmt else stmt` ，这被称为**产生式**，其中，关键字（if）和括号这样的词法单元被称为**终结符号**，expr 和 stmt 这样的变量表示终结符号的序列，它们被称为**非终结符号**。*预定义的符号和由这些预定义的符号表示的变量。所谓终结，是指终结语法分析，任何非终结符号都将被解析为终结符号串。在语法分析中，一个终结符号也意味着终结对前面这些符号的分析，将箭头指向下一个终结符号。*
	- 上下文无关法由四个部分组成：终结符号集合，终结符号也被称为词法单元，是该文法所定义的基本符号的集合；非终结符号集合，非终结符号也被称为语法变量，是终结符号串的集合；产生式集合，每个产生式包括一个称为产生式头或左部的非终结符号，以及一个称为产生式体或右部的由终结符号和非终结符号组成的序列（*产生式 = 产生式头 → 产生式体；产生式头 = 非终结符号；产生式体 = 非终结符号 + 终结符号*）；指定一个非终结符号为**开始符号**。
	> 词法单元由名字与属性值组成，它的名字由抽象符号组成。确切的讲，词法单元的名字是文法中的终结符号。如果词法单元具有属性值，那么该属性值将指向符号表中的附加信息。
	- 产生式头与产生式体用箭头分隔，它表示「具有如下形式」。同一产生式头可能对应多个不同的产生式体，此时可以将产生式体用竖线（|）分隔，它读作「或」。某一非终结符号作为产生式的头，那么我们说这个产生式是该非终结符号的产生式。一个终结符号串是由零个或多个终结符号组成的序列，零个终结符号组成的串称为空串，用 ∊ 表示。*书中，终结符号用黑体，非终结符号用斜体。见[[产生式列表]]。*
	- 从开始符号出发，不断地将某个非终结符号替换为该非终结符号的某个产生式的体，最终推导得到所有终结符号串的集合称为该文法定义的**语言**。*语言，将所有说话者自己定义的记号都还原为语言固有的符号。*
- 语法分析的任务是：接受一个终结符号串作为输入，找出从文法的开始符号推导出这个串的方法。如果不能，那么这个该终结符号串包含错误。语法分析将自开始符号推导语言的过程展示为语法分析树。
	- *已学习一小时。*
	- 某一文法可能被解析为多种不同的语法分析树，它们能生成同一个给定的终结符号串。这样的文法称为具有**二义性**。这些语法分析树尽管能生成同一终结符号串，但它们的语义可能不同，例如 `(1 - 2) + 3` 与 `1 - (2 + 3)` 。因此，应当为编译应用设计出没有二义性的文法，或者附加特定的规则消除二义性。
	- 为此，规定运算符的**结合性**。当某一运算分量两侧都有运算符时，需要确定它与哪个运算符结合。在大多数程序设计语言中，加减乘除四个运算符都是左结合的，即当一个运算分量两侧都有这些运算符时，它与左侧的运算符结合；指数运算符与赋值运算符是右结合的。*所以，似乎 `1 + a = 2` 被解析为 `1 + (a = 2)` 。但是，等号一般不允许出现在表达式内部。*
	- 规定运算符的**优先级**。用**因子**表示任何不能被运算符分开的表达式。用**项**表示可能被高优先级运算符分开而不能被低优先级运算符分开的表达式。任何被括号括起来的表达式都是因子。
	- 任何不以陈述（statement）结尾的表达式都应当以分号结尾。if 和 while 以及块结构中，它们结尾的陈述被自动生成分号。
- 语法制导翻译通过向产生式附加规则或程序片段实现。语法制导的**翻译方案**是将程序片段附加到产生式上的表示法。**属性**表示与某个程序构造相关的任意的量，当使用文法符号表示程序构造时，这些属性也可以与表示程序构造的文法符号关联。
	- 中缀表达式是运算符号在运算分量中间的表达式，后缀表达式是运算符号在运算分量之后的表达式。运算符的位置和它的运算分量数决定后缀表达式只有一种解码方式，因此后缀表达式中不需要括号。
- 将每个文法符号与它的属性集合关联（从而将语法树的每个节点与它的属性集合关联），并将每个产生式与一组[[语义]]规则关联，这些规则用于计算与该产生式中符号相关联的属性值，这一过程被称为**语法制导定义**。语义规则使用「‖」表示字符串的连接运算符。*原来，语义到底表示符号所指代的客体的属性。*
	- 对于某一文法符号 X ，有属性值 a ，则用 X.a 表示该文法符号对应的属性值。如果某一语法分析树的每个节点都被标注属性值，那么它被称为**注释**的语法分析树，简称注释分析树。如果语法分析树上某节点的某一属性的值仅由该节点的属性值及其子节点的属性值决定，那么这一属性被称为**综合属性**；如果它的值也被父节点的属性值决定，那么它被称为**继承属性**。
	- 一个非终结符号在产生式的不同位置，往往具有不同的属性值，因此约定，当它出现在产生式头时不下标，当它出现在产生式体的不同位置时分别下标。
	- 简单语法制导定义是指，要得到代表产生式头部的非终结符号的翻译结果的字符串，只需要将产生式体中各非终结符号的翻译结果按照它们在非终结符号中的出现顺序连接起来，并在其中穿插一些附加的串即可。
- 树的**遍历**用于描述属性的求值过程，以及翻译方案中各个代码片段的执行过程。遍历自根节点开始，按照某个顺序访问各个节点的子节点。深度优先的遍历尽可能地访问尚未被访问的子节点，因此它总是尽可能快地访问离根节点最远的节点（即最深的节点）。
	- 遍历对某一节点的属性求值要求该属性依赖的其他属性都已计算完毕，综合属性可以在自底向上遍历后计算。自底向上遍历是指完成某个节点的所有子节点的属性值的计算后才开始该节点的属性值的计算。既有综合节点，又有继承节点的情况下，节点属性的计算顺序变得复杂。
	- 遍历一棵树时，在每个节点上执行特定的动作（*见下语义动作*）。如果动作在第一次访问某节点时被执行，那么该遍历被称为前序遍历；如果动作在最后一次离开某节点时被执行，那么该遍历被称为后序遍历。
- 不同于语法制导定义，**语法制导翻译方案**是在文法产生式中附加某些程序片段来描述翻译结果的表示方法。这些被嵌入到产生式体中的程序片段称为**语义动作**，当生成语法树时，这些语义动作也被构造为子节点，用虚线与父节点连接。*也就是说，语法制导定义为语法树的节点附加属性，语法制导翻译方案则在语法树上添加动作节点。*
- 语法分析是从文法生成终结符号串的过程。语法分析器总是一次性地自左向右扫描输入，每次向前看一个终结符号，扫描时构造出分析树的各个部分。语法分析方法可以分为自顶向下方法和自底向上方法。自顶向下语法分析器中，构造过程从根节点开始，逐渐向叶子节点方向进行；自底向上语法分析器中，构造过程从叶子节点开始，逐步构造出根节点。
	- **自顶向下**地构造语法分析树时，以开始非终结符作为根节点的标号，对每个标号为某非终结符号的节点，选择它的产生式并为该产生式体中的各个符号构造子节点，然后寻找下一个节点构造子树。*这一过程也就是先构建根节点，然后一边扫描输入串，一边构建节点；一个箭头指向当前扫描的输入串中的符号，另一个箭头指向当前构建的节点的标号。*
	- 输入中当前扫描的终结符号被称为向前看符号（`lookahead`），它实际上被扫描器存储为变量。如果当前正考虑的语法分析树的节点的标号是一个终结符号，并且与向前看符号匹配，那么词法分析树的箭头和输入的箭头都前进一步。*如果当前扫描的不是终结符号呢？*
	- 每次为标号为非终结符号的节点选择产生式的过程是重复试错的过程，它将从可选的诸多产生式中选择一个，如果该产生式不合适，即使用该产生式无法构造出与当前输入串相匹配的语法分析树，那么进行回溯，重新选择产生式。如果 ∊ 是可选的产生式之一，它通常被作为默认选项，即任何其他产生式都不适合时，才使用它。
	- *所谓语法制导翻译器，实际上也是由 C 语言或其他语言构建的文本处理程序，它获取输入的字符串，输出为中间语言的字符串。*
- **预测分析法**可以避免回溯与重新选择产生式。预测分析法引入过程 `match(t)` 。过程 `match(t)` 将它的参数和向前看符号比较，如果匹配就前进到下一个输入终结符号。*它的参数是当前处理的字符串，如果该参数与向前看符号不匹配，也就是说，当前处理的是非终结符号，该过程就通过预测分析将其翻译为终结字符串。*
	- 预测分析需要知道哪些符号可能成为一个产生式体所生成串的第一个符号，为此定义 `FIRST(ɑ)` 为可以由 ɑ 生成的一个或多个终结符号串的第一个符号的集合，其中 ɑ 表示一个文法符号（终结或非终结）串。*也就是说，预测分析法使用`FIRST(ɑ)` 记忆某一符号之后可能的终结符号。*
	- 如果 ɑ 以某个终结符号开头，那么这个终结符号就是 `FIRST(ɑ)` 集合内的全部（唯一）成员；如果 ɑ 以某个非终结符号开头，且该非终结符号的所有产生式都以某个（*些*）终结符号开头，那么这些终结符号就是 `FIRST(ɑ)` 集合内的所有成员。如果 ɑ 是或者可以生成 ∊ ，那么 ∊ 也是集合内的成员。
	- *注意，这里所做的事是扫描输入符号串，选择产生式，构造语法分析树。似乎扫描输入符号串时箭头总是指向终结符号，被称为向前看符号。然后，对于树中正在考虑的节点，它对应的产生式体为 ɑ ，使用 `FIRST(ɑ)` 选择产生式。如果对于同一节点，有多个对应的产生式体，分别记为 ɑ、ʙ ，那么，向前看符号在哪个集合内，选用哪个集合。这样，预测分析法就将试用回溯的做法结合向前看符号与下一步可能的符号集合改变为预测选用产生式的做法。*
	- 在预测分析法中，带有 ∊ 的集合也被作为默认选择，即只有当向前看符号不在任何其他集合内时，才使用该集合。
	- 形如 `A → A + a` 的产生式被认为是左递归的，即产生式体的第一个符号与产生式头的符号相同。由于每次处理产生式体的第一个符号，都将循环至该产生式头，其间不会经历向前看符号的跳跃，因此左递归的产生式将导致预测分析法的无限循环。预测分析法不能处理左递归文法。
- 词法分析从输入中读取字符，形成词法单元。词法单元包括终结符号和属性值信息。构成词法单元的输入字符序列被称为词素。词法分析器将剔除输入中的空白和注释。对于某些字符，词法分析器会预读，以确定它是单独作为词法单元还是与其它字符共同作为词法单元，预读字符将输入缓存区。
	- 字符串可能作为**标识符**为变量、函数、数组命名，也可能作为**关键字**被保留。对于出现在输入中的标识符，它们将被词法分析器赋予相同的终结符号，例如 id ，然后附加属性生成词法单元。对于出现在输入中的字符串，词法分析器将检索字符串表，只有当它们不是保留字时才视作标识符。
	- 对于出现在输入中的数位序列，词法分析器将它们赋予相同的终结符号（num），这一终结符号与根据这些数位序列计算得到的整型属性值组成词法单元。*表示为 <num, 31> 。*
- 符号表供编译器用于保存有关源程序构造的各种信息的数据结构。符号表通常需要支持同一标识符在同一程序中的多重声明，因此一般为每个作用域建立一个单独的符号表，形成符号表栈。进入和离开某一作用域（块）时，编译器将分别设置和释放相关的符号表。环境（env）由最下层的符号表指示。为了使上层的符号表可以访问下层的符号表，需要将它们连接起来，形成符号表链表（事实上，它们被连接到环境，形成的是它们在环境中对象的链表，env 对象链表）。
	- 符号表的作用是将信息从声明的地方传递到实际使用的地方。
- 编译器的前端部分将形成中间代码，有两种形式的中间代码，分别是抽象语法树和线性表示形式，后者如三地址代码。实际上，编译器只会为当前处理的某一部分生成抽象语法树，生成线性代码后便马上释放它，甚至编译器不会形成抽象语法树，只是将它作为逻辑上的一环，直接形成线性代码。
- *[[2022-09-25]]，六个小时，至 67 页，第二章完。此书搁置。*
---
